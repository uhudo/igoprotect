# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "create(address,uint64,uint64,uint64)void": {
            "call_config": {
                "no_op": "CREATE"
            }
        },
        "set_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64))void": {
            "structs": {
                "val_config_man": {
                    "name": "ValConfigMan",
                    "elements": [
                        [
                            "hw_cat",
                            "uint64"
                        ],
                        [
                            "min_amt",
                            "uint64"
                        ],
                        [
                            "max_amt",
                            "uint64"
                        ],
                        [
                            "fee_setup",
                            "uint64"
                        ],
                        [
                            "fee_round",
                            "uint64"
                        ],
                        [
                            "deposit",
                            "uint64"
                        ],
                        [
                            "setup_rounds",
                            "uint64"
                        ],
                        [
                            "confirmation_rounds",
                            "uint64"
                        ],
                        [
                            "max_breach",
                            "uint64"
                        ],
                        [
                            "breach_rounds",
                            "uint64"
                        ],
                        [
                            "uptime_gar",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "set_extra((byte[30],byte[70]))void": {
            "structs": {
                "val_config_extra": {
                    "name": "ValConfigExtra",
                    "elements": [
                        [
                            "name",
                            "byte[30]"
                        ],
                        [
                            "link",
                            "byte[70]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "deposit_keys(byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "confirm_keys(uint64,byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_generated()(uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "Struct2UInt64",
                    "elements": [
                        [
                            "a",
                            "uint64"
                        ],
                        [
                            "b",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "delete_application": "CALL"
            }
        },
        "keys_not_confirmed()(uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "Struct2UInt64",
                    "elements": [
                        [
                            "a",
                            "uint64"
                        ],
                        [
                            "b",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "delete_application": "CALL"
            }
        },
        "end_contract()(uint64,uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "Struct3UInt64",
                    "elements": [
                        [
                            "a",
                            "uint64"
                        ],
                        [
                            "b",
                            "uint64"
                        ],
                        [
                            "c",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "delete_application": "CALL"
            }
        },
        "stake_limit_breach()bool": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "dereg_breach()bool": {
            "call_config": {
                "no_op": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmFwcHJvdmFsX3Byb2dyYW06CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fZW50cnlwb2ludEAyCiAgICBjYWxsc3ViIF9faW5pdF9fCgptYWluX2VudHJ5cG9pbnRAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjctMjgKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QpOgogICAgbWV0aG9kICJjcmVhdGUoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgbWV0aG9kICJzZXRfbWFuZGF0b3J5KCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkIgogICAgbWV0aG9kICJzZXRfZXh0cmEoKGJ5dGVbMzBdLGJ5dGVbNzBdKSl2b2lkIgogICAgbWV0aG9kICJkZXBvc2l0X2tleXMoYnl0ZVszMl0sYnl0ZVszMl0sYnl0ZVs2NF0sdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgbWV0aG9kICJjb25maXJtX2tleXModWludDY0LGJ5dGVbMzJdLGJ5dGVbMzJdLGJ5dGVbNjRdLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIG1ldGhvZCAia2V5c19ub3RfZ2VuZXJhdGVkKCkodWludDY0LHVpbnQ2NCkiCiAgICBtZXRob2QgImtleXNfbm90X2NvbmZpcm1lZCgpKHVpbnQ2NCx1aW50NjQpIgogICAgbWV0aG9kICJlbmRfY29udHJhY3QoKSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBtZXRob2QgInN0YWtlX2xpbWl0X2JyZWFjaCgpYm9vbCIKICAgIG1ldGhvZCAiZGVyZWdfYnJlYWNoKClib29sIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl9jcmVhdGVfcm91dGVAMyBtYWluX3NldF9tYW5kYXRvcnlfcm91dGVANCBtYWluX3NldF9leHRyYV9yb3V0ZUA1IG1haW5fZGVwb3NpdF9rZXlzX3JvdXRlQDYgbWFpbl9jb25maXJtX2tleXNfcm91dGVANyBtYWluX2tleXNfbm90X2dlbmVyYXRlZF9yb3V0ZUA4IG1haW5fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDkgbWFpbl9lbmRfY29udHJhY3Rfcm91dGVAMTAgbWFpbl9zdGFrZV9saW1pdF9icmVhY2hfcm91dGVAMTEgbWFpbl9kZXJlZ19icmVhY2hfcm91dGVAMTIKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5fY3JlYXRlX3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoY3JlYXRlPSJyZXF1aXJlIikKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNy0yOAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoY3JlYXRlPSJyZXF1aXJlIikKICAgIGNhbGxzdWIgY3JlYXRlCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3NldF9tYW5kYXRvcnlfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNy0yOAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X21hbmRhdG9yeQogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9zZXRfZXh0cmFfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNy0yOAogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X2V4dHJhCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2RlcG9zaXRfa2V5c19yb3V0ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3LTI4CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBkZXBvc2l0X2tleXMKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fY29uZmlybV9rZXlzX3JvdXRlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE0MgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjctMjgKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxNDIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbmZpcm1fa2V5cwogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9rZXlzX25vdF9nZW5lcmF0ZWRfcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTgzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBpbnQgRGVsZXRlQXBwbGljYXRpb24KICAgID09CiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIERlbGV0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBrZXlzX25vdF9nZW5lcmF0ZWQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE5OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJEZWxldGVBcHBsaWNhdGlvbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgaW50IERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBEZWxldGVBcHBsaWNhdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIga2V5c19ub3RfY29uZmlybWVkCiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2VuZF9jb250cmFjdF9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjE4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBpbnQgRGVsZXRlQXBwbGljYXRpb24KICAgID09CiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIERlbGV0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBlbmRfY29udHJhY3QKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fc3Rha2VfbGltaXRfYnJlYWNoX3JvdXRlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIHN0YWtlX2xpbWl0X2JyZWFjaAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9kZXJlZ19icmVhY2hfcm91dGVAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI5MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZGVyZWdfYnJlYWNoCiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jcmVhdGUoZGVsX2FjYzogYnl0ZXMsIG5vdGljZWJvYXJkX2FwcF9pZDogYnl0ZXMsIHJvdW5kX3N0YXJ0OiBieXRlcywgcm91bmRfZW5kOiBieXRlcykgLT4gdm9pZDoKY3JlYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4NC05MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICAvLyBkZWYgY3JlYXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FjYzogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIG5vdGljZWJvYXJkX2FwcF9pZDogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIHJvdW5kX2VuZDogYXJjNC5VSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA0IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTMtOTQKICAgIC8vICMgU2V0IGdsb2JhbCB2YXJpYWJsZXMKICAgIC8vIHNlbGYuZGVsX2FjYyA9IGRlbF9hY2MubmF0aXZlCiAgICBieXRlICJkZWxfYWNjIgogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NQogICAgLy8gc2VsZi5yb3VuZF9zdGFydCA9IHJvdW5kX3N0YXJ0Lm5hdGl2ZQogICAgZnJhbWVfZGlnIC0yCiAgICBidG9pCiAgICBieXRlICJyb3VuZF9zdGFydCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2CiAgICAvLyBzZWxmLnJvdW5kX2VuZCA9IHJvdW5kX2VuZC5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMQogICAgYnRvaQogICAgYnl0ZSAicm91bmRfZW5kIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTcKICAgIC8vIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkID0gbm90aWNlYm9hcmRfYXBwX2lkLm5hdGl2ZQogICAgZnJhbWVfZGlnIC0zCiAgICBidG9pCiAgICBieXRlICJub3RpY2Vib2FyZF9hcHBfaWQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5OAogICAgLy8gc2VsZi52YWxfYXBwX2lkID0gR2xvYmFsLmNhbGxlcl9hcHBsaWNhdGlvbl9pZAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGdsb2JhbCBDYWxsZXJBcHBsaWNhdGlvbklECiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDAKICAgIC8vIHNlbGYubGFzdF9icmVhY2hfcm91bmQgPSBzZWxmLnJvdW5kX3N0YXJ0CiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHJvdW5kX3N0YXJ0IGV4aXN0cwogICAgYnl0ZSAibGFzdF9icmVhY2hfcm91bmQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDEKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5zZXRfbWFuZGF0b3J5KHZhbF9jb25maWdfbWFuOiBieXRlcykgLT4gdm9pZDoKc2V0X21hbmRhdG9yeToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAzLTEwNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBzZXRfbWFuZGF0b3J5KHNlbGYsIHZhbF9jb25maWdfbWFuOiBWYWxDb25maWdNYW4pIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA1CiAgICAvLyBhc3NlcnQgc2VsZi5jYWxsZWRfYnlfdmFsaWRhdG9yX2FkKCksICJOb3QgY2FsbGVkIGJ5IHZhbGlkYXRvciBhcHAuIgogICAgY2FsbHN1YiBjYWxsZWRfYnlfdmFsaWRhdG9yX2FkCiAgICBhc3NlcnQgLy8gTm90IGNhbGxlZCBieSB2YWxpZGF0b3IgYXBwLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDYKICAgIC8vIHNlbGYudmFsX2NvbmZpZ19tYW4gPSB2YWxfY29uZmlnX21hbi5jb3B5KCkKICAgIGJ5dGUgInZhbF9jb25maWdfbWFuIgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDcKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jYWxsZWRfYnlfdmFsaWRhdG9yX2FkKCkgLT4gdWludDY0OgpjYWxsZWRfYnlfdmFsaWRhdG9yX2FkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMjEtMzI1CiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSBJbnRlcm5hbCBmdW5jdGlvbnMgLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGNhbGxlZF9ieV92YWxpZGF0b3JfYWQoc2VsZikgLT4gYm9vbDoKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMjYKICAgIC8vIHJldHVybiBHbG9iYWwuY2FsbGVyX2FwcGxpY2F0aW9uX2lkID09IHNlbGYudmFsX2FwcF9pZAogICAgZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKICAgIGludCAwCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfYXBwX2lkIGV4aXN0cwogICAgPT0KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Quc2V0X2V4dHJhKHZhbF9jb25maWdfZXh0cmE6IGJ5dGVzKSAtPiB2b2lkOgpzZXRfZXh0cmE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwOS0xMTAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X2V4dHJhKHNlbGYsIHZhbF9jb25maWdfZXh0cmE6IFZhbENvbmZpZ0V4dHJhKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExMQogICAgLy8gYXNzZXJ0IHNlbGYuY2FsbGVkX2J5X3ZhbGlkYXRvcl9hZCgpLCAiTm90IGNhbGxlZCBieSB2YWxpZGF0b3IgYXBwLiIKICAgIGNhbGxzdWIgY2FsbGVkX2J5X3ZhbGlkYXRvcl9hZAogICAgYXNzZXJ0IC8vIE5vdCBjYWxsZWQgYnkgdmFsaWRhdG9yIGFwcC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEyCiAgICAvLyBzZWxmLnZhbF9jb25maWdfZXh0cmEgPSB2YWxfY29uZmlnX2V4dHJhLmNvcHkoKQogICAgYnl0ZSAidmFsX2NvbmZpZ19leHRyYSIKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEzCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuZGVwb3NpdF9rZXlzKHNlbF9rZXk6IGJ5dGVzLCB2b3RlX2tleTogYnl0ZXMsIHN0YXRlX3Byb29mX2tleTogYnl0ZXMsIHZvdGVfa2V5X2RpbHV0aW9uOiBieXRlcywgcm91bmRfc3RhcnQ6IGJ5dGVzLCByb3VuZF9lbmQ6IGJ5dGVzKSAtPiBieXRlczoKZGVwb3NpdF9rZXlzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTUtMTI0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGRlcG9zaXRfa2V5cygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHNlbF9rZXk6IFNlbEtleSwKICAgIC8vICAgICB2b3RlX2tleTogVm90ZUtleSwKICAgIC8vICAgICBzdGF0ZV9wcm9vZl9rZXk6IFN0YXRlUHJvb2ZLZXksCiAgICAvLyAgICAgdm90ZV9rZXlfZGlsdXRpb246IGFyYzQuVUludDY0LAogICAgLy8gICAgIHJvdW5kX3N0YXJ0OiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByb3VuZF9lbmQ6IGFyYzQuVUludDY0LAogICAgLy8gKSAtPiBhcmM0LlVJbnQ2NDoKICAgIHByb3RvIDYgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjYKICAgIC8vIGFzc2VydCBzZWxmLmNhbGxlZF9ieV92YWxpZGF0b3JfYWQoKSwgIk5vdCBjYWxsZWQgYnkgdmFsaWRhdG9yIGFwcC4iCiAgICBjYWxsc3ViIGNhbGxlZF9ieV92YWxpZGF0b3JfYWQKICAgIGFzc2VydCAvLyBOb3QgY2FsbGVkIGJ5IHZhbGlkYXRvciBhcHAuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyNwogICAgLy8gYXNzZXJ0IHNlbGYucGFydF9rZXlzX2RlcG9zaXRlZCA9PSBGYWxzZSwgIktleXMgY2FuIGJlIHNldCBvbmx5IG9uY2UuIgogICAgaW50IDAKICAgIGJ5dGUgInBhcnRfa2V5c19kZXBvc2l0ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHBhcnRfa2V5c19kZXBvc2l0ZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gS2V5cyBjYW4gYmUgc2V0IG9ubHkgb25jZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTI5CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9zdGFydCA9PSByb3VuZF9zdGFydCwgIlN0YXJ0IHJvdW5kIGlzbid0IGFzIGFncmVlZC4iCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHJvdW5kX3N0YXJ0IGV4aXN0cwogICAgaXRvYgogICAgZnJhbWVfZGlnIC0yCiAgICBiPT0KICAgIGFzc2VydCAvLyBTdGFydCByb3VuZCBpc24ndCBhcyBhZ3JlZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEzMAogICAgLy8gYXNzZXJ0IHNlbGYucm91bmRfZW5kID09IHJvdW5kX2VuZCwgIkVuZCByb3VuZCBpc24ndCBhcyBhZ3JlZWQuIgogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcm91bmRfZW5kIGV4aXN0cwogICAgaXRvYgogICAgZnJhbWVfZGlnIC0xCiAgICBiPT0KICAgIGFzc2VydCAvLyBFbmQgcm91bmQgaXNuJ3QgYXMgYWdyZWVkLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMzIKICAgIC8vIHNlbGYudm90ZV9rZXlfZGlsdXRpb24gPSB2b3RlX2tleV9kaWx1dGlvbi5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMwogICAgYnRvaQogICAgYnl0ZSAidm90ZV9rZXlfZGlsdXRpb24iCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMzMKICAgIC8vIHNlbGYuc2VsX2tleSA9IHNlbF9rZXkuY29weSgpCiAgICBieXRlICJzZWxfa2V5IgogICAgZnJhbWVfZGlnIC02CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMzQKICAgIC8vIHNlbGYudm90ZV9rZXkgPSB2b3RlX2tleS5jb3B5KCkKICAgIGJ5dGUgInZvdGVfa2V5IgogICAgZnJhbWVfZGlnIC01CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMzUKICAgIC8vIHNlbGYuc3RhdGVfcHJvb2Zfa2V5ID0gc3RhdGVfcHJvb2Zfa2V5LmNvcHkoKQogICAgYnl0ZSAic3RhdGVfcHJvb2Zfa2V5IgogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMzcKICAgIC8vIHNlbGYucGFydF9rZXlzX2RlcG9zaXRlZCA9IFRydWUKICAgIGJ5dGUgInBhcnRfa2V5c19kZXBvc2l0ZWQiCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTM5LTE0MAogICAgLy8gIyBSZXR1cm4gdGhlIGFncmVlZCBmZWUgZm9yIHNldHRpbmcgdXAgdGhlIHZhbGlkYXRvcgogICAgLy8gcmV0dXJuIHNlbGYudmFsX2NvbmZpZ19tYW4uZmVlX3NldHVwCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNvbmZpcm1fa2V5cyhmZWVfb3BlcmF0aW9uX3BheW1lbnRfYW1vdW50OiBieXRlcywgc2VsX2tleTogYnl0ZXMsIHZvdGVfa2V5OiBieXRlcywgc3RhdGVfcHJvb2Zfa2V5OiBieXRlcywgdm90ZV9rZXlfZGlsdXRpb246IGJ5dGVzLCByb3VuZF9zdGFydDogYnl0ZXMsIHJvdW5kX2VuZDogYnl0ZXMpIC0+IGJ5dGVzOgpjb25maXJtX2tleXM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE0Mi0xNTIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29uZmlybV9rZXlzKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZmVlX29wZXJhdGlvbl9wYXltZW50X2Ftb3VudDogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgc2VsX2tleTogU2VsS2V5LAogICAgLy8gICAgIHZvdGVfa2V5OiBWb3RlS2V5LAogICAgLy8gICAgIHN0YXRlX3Byb29mX2tleTogU3RhdGVQcm9vZktleSwKICAgIC8vICAgICB2b3RlX2tleV9kaWx1dGlvbjogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIHJvdW5kX2VuZDogYXJjNC5VSW50NjQsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gNyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE1NAogICAgLy8gYXNzZXJ0IHNlbGYuY2FsbGVkX2J5X3ZhbGlkYXRvcl9hZCgpLCAiTm90IGNhbGxlZCBieSB2YWxpZGF0b3IgYXBwLiIKICAgIGNhbGxzdWIgY2FsbGVkX2J5X3ZhbGlkYXRvcl9hZAogICAgYXNzZXJ0IC8vIE5vdCBjYWxsZWQgYnkgdmFsaWRhdG9yIGFwcC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTU3CiAgICAvLyBzZWxmLnBhcnRfa2V5c19kZXBvc2l0ZWQgPT0gVHJ1ZQogICAgaW50IDAKICAgIGJ5dGUgInBhcnRfa2V5c19kZXBvc2l0ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHBhcnRfa2V5c19kZXBvc2l0ZWQgZXhpc3RzCiAgICBpbnQgMQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTU2LTE1OAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLnBhcnRfa2V5c19kZXBvc2l0ZWQgPT0gVHJ1ZQogICAgLy8gKSwgIktleXMgY2FuJ3QgYmUgYWNjZXB0ZWQgaWYgdGhleSBoYXZlbid0IGJlZW4gZGVwb3NpdGVkLiIKICAgIGFzc2VydCAvLyBLZXlzIGNhbid0IGJlIGFjY2VwdGVkIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGRlcG9zaXRlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTYxCiAgICAvLyBzZWxmLnJvdW5kX3N0YXJ0IDwgR2xvYmFsLnJvdW5kCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHJvdW5kX3N0YXJ0IGV4aXN0cwogICAgZ2xvYmFsIFJvdW5kCiAgICA8CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE2MC0xNjIKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9zdGFydCA8IEdsb2JhbC5yb3VuZAogICAgLy8gKSwgIktleXMgY2FuJ3QgYmUgY29uZmlybWVkIGZvciBmdXR1cmUgKHJlcXVpcmVtZW50IG9mIGNvbnNlbnN1cyBwcm90b2NvbCkuIgogICAgYXNzZXJ0IC8vIEtleXMgY2FuJ3QgYmUgY29uZmlybWVkIGZvciBmdXR1cmUgKHJlcXVpcmVtZW50IG9mIGNvbnNlbnN1cyBwcm90b2NvbCkuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE2NC0xNjUKICAgIC8vICMgQ2hlY2sgaWYga2V5IHJlZyBwYXJhbWV0ZXJzIGFyZSB0aGUgc2FtZSBhcyB3ZXJlIGRlcG9zaXRlZAogICAgLy8gYXNzZXJ0IHNlbF9rZXkgPT0gc2VsZi5zZWxfa2V5LCAiU2VsZWN0aW9uIGtleSIKICAgIGludCAwCiAgICBieXRlICJzZWxfa2V5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxfa2V5IGV4aXN0cwogICAgZnJhbWVfZGlnIC02CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbGVjdGlvbiBrZXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTY2CiAgICAvLyBhc3NlcnQgdm90ZV9rZXkgPT0gc2VsZi52b3RlX2tleSwgIlZvdGUga2V5IgogICAgaW50IDAKICAgIGJ5dGUgInZvdGVfa2V5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2b3RlX2tleSBleGlzdHMKICAgIGZyYW1lX2RpZyAtNQogICAgPT0KICAgIGFzc2VydCAvLyBWb3RlIGtleQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxNjcKICAgIC8vIGFzc2VydCBzdGF0ZV9wcm9vZl9rZXkgPT0gc2VsZi5zdGF0ZV9wcm9vZl9rZXksICJTdGF0ZSBwcm9vZiBrZXkiCiAgICBpbnQgMAogICAgYnl0ZSAic3RhdGVfcHJvb2Zfa2V5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzdGF0ZV9wcm9vZl9rZXkgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTQKICAgID09CiAgICBhc3NlcnQgLy8gU3RhdGUgcHJvb2Yga2V5CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE2OAogICAgLy8gYXNzZXJ0IHZvdGVfa2V5X2RpbHV0aW9uID09IHNlbGYudm90ZV9rZXlfZGlsdXRpb24sICJWb3RlIGtleSBkaWx1dGlvbiIKICAgIGludCAwCiAgICBieXRlICJ2b3RlX2tleV9kaWx1dGlvbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdm90ZV9rZXlfZGlsdXRpb24gZXhpc3RzCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTMKICAgIGI9PQogICAgYXNzZXJ0IC8vIFZvdGUga2V5IGRpbHV0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE2OQogICAgLy8gYXNzZXJ0IHJvdW5kX3N0YXJ0ID09IHNlbGYucm91bmRfc3RhcnQsICJSb3VuZCBzdGFydCIKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9zdGFydCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcm91bmRfc3RhcnQgZXhpc3RzCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIGI9PQogICAgYXNzZXJ0IC8vIFJvdW5kIHN0YXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE3MAogICAgLy8gYXNzZXJ0IHJvdW5kX2VuZCA9PSBzZWxmLnJvdW5kX2VuZCwgIlJvdW5kIGVuZCIKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHJvdW5kX2VuZCBleGlzdHMKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAtMQogICAgYj09CiAgICBhc3NlcnQgLy8gUm91bmQgZW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE3Mi0xNzQKICAgIC8vICMgQXNzZXJ0IGNvcnJlY3QgYW1vdW50IG9mIG9wZXJhdGlvbmFsIGZlZSB3YXMgcGFpZCB0byB0aGUgbm90aWNlYm9hcmQgKHJlY2VpdmVyIGNoZWNrZWQgaW4gTm90aWNlYm9hcmQpCiAgICAvLyAjIFRPIERPOiBDaGVjayBpZiBJIG5lZWQgdG8gdGFrZSBjYXJlIG9mIG92ZXJmbG93cyB0byBwcmV2ZW50IG1hbmlwdWxhdGlvbiBvZiBlYXJuaW5ncwogICAgLy8gYXNzZXJ0IGZlZV9vcGVyYXRpb25fcGF5bWVudF9hbW91bnQgPT0gc2VsZi52YWxfY29uZmlnX21hbi5mZWVfcm91bmQubmF0aXZlICogKAogICAgaW50IDAKICAgIGJ5dGUgInZhbF9jb25maWdfbWFuIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfY29uZmlnX21hbiBleGlzdHMKICAgIGV4dHJhY3QgMzIgOAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxNzUKICAgIC8vIHNlbGYucm91bmRfZW5kIC0gc2VsZi5yb3VuZF9zdGFydAogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcm91bmRfZW5kIGV4aXN0cwogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayByb3VuZF9zdGFydCBleGlzdHMKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTcyLTE3NgogICAgLy8gIyBBc3NlcnQgY29ycmVjdCBhbW91bnQgb2Ygb3BlcmF0aW9uYWwgZmVlIHdhcyBwYWlkIHRvIHRoZSBub3RpY2Vib2FyZCAocmVjZWl2ZXIgY2hlY2tlZCBpbiBOb3RpY2Vib2FyZCkKICAgIC8vICMgVE8gRE86IENoZWNrIGlmIEkgbmVlZCB0byB0YWtlIGNhcmUgb2Ygb3ZlcmZsb3dzIHRvIHByZXZlbnQgbWFuaXB1bGF0aW9uIG9mIGVhcm5pbmdzCiAgICAvLyBhc3NlcnQgZmVlX29wZXJhdGlvbl9wYXltZW50X2Ftb3VudCA9PSBzZWxmLnZhbF9jb25maWdfbWFuLmZlZV9yb3VuZC5uYXRpdmUgKiAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9lbmQgLSBzZWxmLnJvdW5kX3N0YXJ0CiAgICAvLyApLCAiT3BlcmF0aW9uYWwgZmVlIHdhcyBpbnN1ZmZpY2llbnQuIgogICAgKgogICAgaXRvYgogICAgZnJhbWVfZGlnIC03CiAgICBiPT0KICAgIGFzc2VydCAvLyBPcGVyYXRpb25hbCBmZWUgd2FzIGluc3VmZmljaWVudC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTc4CiAgICAvLyBzZWxmLmtleXNfY29uZmlybWVkID0gVHJ1ZQogICAgYnl0ZSAia2V5c19jb25maXJtZWQiCiAgICBpbnQgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTgwLTE4MQogICAgLy8gIyBSZXR1cm4gZWFybmVkIGFncmVlZCBzZXR1cCBmZWUKICAgIC8vIHJldHVybiBzZWxmLnZhbF9jb25maWdfbWFuLmZlZV9zZXR1cAogICAgaW50IDAKICAgIGJ5dGUgInZhbF9jb25maWdfbWFuIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfY29uZmlnX21hbiBleGlzdHMKICAgIGV4dHJhY3QgMjQgOAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5rZXlzX25vdF9nZW5lcmF0ZWQoKSAtPiBieXRlczoKa2V5c19ub3RfZ2VuZXJhdGVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxODMtMTg0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICAvLyBkZWYga2V5c19ub3RfZ2VuZXJhdGVkKHNlbGYpIC0+IFN0cnVjdDJVSW50NjQ6CiAgICBwcm90byAwIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTg1CiAgICAvLyBhc3NlcnQgc2VsZi5jYWxsZWRfYnlfdmFsaWRhdG9yX2FkKCksICJOb3QgY2FsbGVkIGJ5IHZhbGlkYXRvciBhcHAuIgogICAgY2FsbHN1YiBjYWxsZWRfYnlfdmFsaWRhdG9yX2FkCiAgICBhc3NlcnQgLy8gTm90IGNhbGxlZCBieSB2YWxpZGF0b3IgYXBwLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxODcKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5wYXJ0X2tleXNfZGVwb3NpdGVkLCAiS2V5cyB3ZXJlIGRlcG9zaXRlZC4iCiAgICBpbnQgMAogICAgYnl0ZSAicGFydF9rZXlzX2RlcG9zaXRlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcGFydF9rZXlzX2RlcG9zaXRlZCBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBLZXlzIHdlcmUgZGVwb3NpdGVkLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxOTAKICAgIC8vIEdsb2JhbC5yb3VuZCA+IHNlbGYucm91bmRfc3RhcnQgKyBzZWxmLnZhbF9jb25maWdfbWFuLnNldHVwX3JvdW5kcy5uYXRpdmUKICAgIGdsb2JhbCBSb3VuZAogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayByb3VuZF9zdGFydCBleGlzdHMKICAgIGludCAwCiAgICBieXRlICJ2YWxfY29uZmlnX21hbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2NvbmZpZ19tYW4gZXhpc3RzCiAgICBleHRyYWN0IDQ4IDgKICAgIGJ0b2kKICAgICsKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTg5LTE5MQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBHbG9iYWwucm91bmQgPiBzZWxmLnJvdW5kX3N0YXJ0ICsgc2VsZi52YWxfY29uZmlnX21hbi5zZXR1cF9yb3VuZHMubmF0aXZlCiAgICAvLyApLCAiT25seSBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkIHNpbmNlIGNvbnRyYWN0IHN0YXJ0LCBjYW4gaXQgYmUgY2xhaW1lZCB0aGF0IGtleXMgaGF2ZW4ndCBiZWVuIGdlbmVyYXRlZC4iCiAgICBhc3NlcnQgLy8gT25seSBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkIHNpbmNlIGNvbnRyYWN0IHN0YXJ0LCBjYW4gaXQgYmUgY2xhaW1lZCB0aGF0IGtleXMgaGF2ZW4ndCBiZWVuIGdlbmVyYXRlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTk1CiAgICAvLyBzZWxmLnZhbF9jb25maWdfbWFuLmRlcG9zaXQsCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCA0MCA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE5NgogICAgLy8gc2VsZi52YWxfY29uZmlnX21hbi5mZWVfc2V0dXAsCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjE5My0xOTcKICAgIC8vICMgUmV0dXJuIGFncmVlZCBkZXBvc2l0IGFuZCBzZXR1cCBmZWUKICAgIC8vIHJldHVybiBTdHJ1Y3QyVUludDY0KAogICAgLy8gICAgIHNlbGYudmFsX2NvbmZpZ19tYW4uZGVwb3NpdCwKICAgIC8vICAgICBzZWxmLnZhbF9jb25maWdfbWFuLmZlZV9zZXR1cCwKICAgIC8vICkKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5rZXlzX25vdF9jb25maXJtZWQoKSAtPiBieXRlczoKa2V5c19ub3RfY29uZmlybWVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxOTktMjAwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICAvLyBkZWYga2V5c19ub3RfY29uZmlybWVkKHNlbGYpIC0+IFN0cnVjdDJVSW50NjQ6CiAgICBwcm90byAwIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjAxCiAgICAvLyBhc3NlcnQgc2VsZi5jYWxsZWRfYnlfdmFsaWRhdG9yX2FkKCksICJOb3QgY2FsbGVkIGJ5IHZhbGlkYXRvciBhcHAuIgogICAgY2FsbHN1YiBjYWxsZWRfYnlfdmFsaWRhdG9yX2FkCiAgICBhc3NlcnQgLy8gTm90IGNhbGxlZCBieSB2YWxpZGF0b3IgYXBwLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMDMKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5rZXlzX2NvbmZpcm1lZCwgIktleXMgaGF2ZW4ndCBiZWVuIGNvbmZpcm1lZC4iCiAgICBpbnQgMAogICAgYnl0ZSAia2V5c19jb25maXJtZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGtleXNfY29uZmlybWVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIEtleXMgaGF2ZW4ndCBiZWVuIGNvbmZpcm1lZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjA2CiAgICAvLyBHbG9iYWwucm91bmQKICAgIGdsb2JhbCBSb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMDcKICAgIC8vID4gc2VsZi5yb3VuZF9zdGFydAogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayByb3VuZF9zdGFydCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjA4CiAgICAvLyArIHNlbGYudmFsX2NvbmZpZ19tYW4uc2V0dXBfcm91bmRzLm5hdGl2ZQogICAgaW50IDAKICAgIGJ5dGUgInZhbF9jb25maWdfbWFuIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfY29uZmlnX21hbiBleGlzdHMKICAgIGV4dHJhY3QgNDggOAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMDctMjA4CiAgICAvLyA+IHNlbGYucm91bmRfc3RhcnQKICAgIC8vICsgc2VsZi52YWxfY29uZmlnX21hbi5zZXR1cF9yb3VuZHMubmF0aXZlCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjIwOQogICAgLy8gKyBzZWxmLnZhbF9jb25maWdfbWFuLmNvbmZpcm1hdGlvbl9yb3VuZHMubmF0aXZlCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCA1NiA4CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjIwNy0yMDkKICAgIC8vID4gc2VsZi5yb3VuZF9zdGFydAogICAgLy8gKyBzZWxmLnZhbF9jb25maWdfbWFuLnNldHVwX3JvdW5kcy5uYXRpdmUKICAgIC8vICsgc2VsZi52YWxfY29uZmlnX21hbi5jb25maXJtYXRpb25fcm91bmRzLm5hdGl2ZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMDYtMjA5CiAgICAvLyBHbG9iYWwucm91bmQKICAgIC8vID4gc2VsZi5yb3VuZF9zdGFydAogICAgLy8gKyBzZWxmLnZhbF9jb25maWdfbWFuLnNldHVwX3JvdW5kcy5uYXRpdmUKICAgIC8vICsgc2VsZi52YWxfY29uZmlnX21hbi5jb25maXJtYXRpb25fcm91bmRzLm5hdGl2ZQogICAgPgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMDUtMjEwCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIEdsb2JhbC5yb3VuZAogICAgLy8gICAgID4gc2VsZi5yb3VuZF9zdGFydAogICAgLy8gICAgICsgc2VsZi52YWxfY29uZmlnX21hbi5zZXR1cF9yb3VuZHMubmF0aXZlCiAgICAvLyAgICAgKyBzZWxmLnZhbF9jb25maWdfbWFuLmNvbmZpcm1hdGlvbl9yb3VuZHMubmF0aXZlCiAgICAvLyApLCAiT25seSBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkIHNpbmNlIGNvbnRyYWN0IHN0YXJ0LCBjYW4gaXQgYmUgY2xhaW1lZCB0aGF0IGtleXMgaGF2ZW4ndCBiZWVuIGNvbmZpcm1lZC4iCiAgICBhc3NlcnQgLy8gT25seSBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkIHNpbmNlIGNvbnRyYWN0IHN0YXJ0LCBjYW4gaXQgYmUgY2xhaW1lZCB0aGF0IGtleXMgaGF2ZW4ndCBiZWVuIGNvbmZpcm1lZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjE0CiAgICAvLyBzZWxmLnZhbF9jb25maWdfbWFuLmRlcG9zaXQsCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCA0MCA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjIxNQogICAgLy8gc2VsZi52YWxfY29uZmlnX21hbi5mZWVfc2V0dXAsCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjIxMi0yMTYKICAgIC8vICMgUmV0dXJuIGFncmVlZCBkZXBvc2l0IGFuZCBzZXR1cCBmZWUKICAgIC8vIHJldHVybiBTdHJ1Y3QyVUludDY0KAogICAgLy8gICAgIHNlbGYudmFsX2NvbmZpZ19tYW4uZGVwb3NpdCwKICAgIC8vICAgICBzZWxmLnZhbF9jb25maWdfbWFuLmZlZV9zZXR1cCwKICAgIC8vICkKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5lbmRfY29udHJhY3QoKSAtPiBieXRlczoKZW5kX2NvbnRyYWN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMTgtMjE5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICAvLyBkZWYgZW5kX2NvbnRyYWN0KHNlbGYpIC0+IFN0cnVjdDNVSW50NjQ6CiAgICBwcm90byAwIDEKICAgIGJ5dGUgIiIKICAgIGR1cG4gNAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMjAKICAgIC8vIGFzc2VydCBzZWxmLmNhbGxlZF9ieV92YWxpZGF0b3JfYWQoKSwgIk5vdCBjYWxsZWQgYnkgdmFsaWRhdG9yIGFwcC4iCiAgICBjYWxsc3ViIGNhbGxlZF9ieV92YWxpZGF0b3JfYWQKICAgIGFzc2VydCAvLyBOb3QgY2FsbGVkIGJ5IHZhbGlkYXRvciBhcHAuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjIyMwogICAgLy8gc2VsZi5wYXJ0X2tleXNfZGVwb3NpdGVkCiAgICBpbnQgMAogICAgYnl0ZSAicGFydF9rZXlzX2RlcG9zaXRlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcGFydF9rZXlzX2RlcG9zaXRlZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjIyLTIyNAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLnBhcnRfa2V5c19kZXBvc2l0ZWQKICAgIC8vICksICJDYW4ndCBlbmQgY29udHJhY3QgdGhpcyB3YXkgaWYga2V5cyBoYXZlbid0IHlldCBiZWVuIGRlcG9zaXRlZC4iCiAgICBhc3NlcnQgLy8gQ2FuJ3QgZW5kIGNvbnRyYWN0IHRoaXMgd2F5IGlmIGtleXMgaGF2ZW4ndCB5ZXQgYmVlbiBkZXBvc2l0ZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjIyNgogICAgLy8gYXNzZXJ0IHNlbGYua2V5c19jb25maXJtZWQsICJDYW4ndCBlbmQgY29udHJhY3QgaWYga2V5cyBoYXZlbid0IGJlZW4gY29uZmlybWVkLiIKICAgIGludCAwCiAgICBieXRlICJrZXlzX2NvbmZpcm1lZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sga2V5c19jb25maXJtZWQgZXhpc3RzCiAgICBhc3NlcnQgLy8gQ2FuJ3QgZW5kIGNvbnRyYWN0IGlmIGtleXMgaGF2ZW4ndCBiZWVuIGNvbmZpcm1lZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjI4LTIyOQogICAgLy8gIyBDYWxjdWxhdGUgYW55IHJlZnVuZCBhbW91bnQgYW5kIHZhbGlkYXRvciBlYXJuaW5ncwogICAgLy8gaWYgR2xvYmFsLnJvdW5kID4gc2VsZi5yb3VuZF9lbmQ6CiAgICBnbG9iYWwgUm91bmQKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHJvdW5kX2VuZCBleGlzdHMKICAgID4KICAgIGJ6IGVuZF9jb250cmFjdF9lbHNlX2JvZHlAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMzAtMjMxCiAgICAvLyAjIENvbnRyYWN0IGhhcyBzdWNjZXNzZnVsbHkgZW5kZWQKICAgIC8vIHJvdW5kc19yZW1haW4gPSBVSW50NjQoMCkKICAgIGludCAwCiAgICBiIGVuZF9jb250cmFjdF9hZnRlcl9pZl9lbHNlQDMKCmVuZF9jb250cmFjdF9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjMzLTIzNAogICAgLy8gIyBDb250cmFjdCBoYXMgcHJlbWF0dXJlbHkgZW5kZWQKICAgIC8vIHJvdW5kc19yZW1haW4gPSBzZWxmLnJvdW5kX2VuZCAtIEdsb2JhbC5yb3VuZAogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcm91bmRfZW5kIGV4aXN0cwogICAgZ2xvYmFsIFJvdW5kCiAgICAtCgplbmRfY29udHJhY3RfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMzYKICAgIC8vIGRlcG9zaXQgPSBzZWxmLnZhbF9jb25maWdfbWFuLmRlcG9zaXQubmF0aXZlCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCA0MCA4CiAgICBidG9pCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMzcKICAgIC8vIHJlZnVuZF9hbW91bnQgPSBzZWxmLnZhbF9jb25maWdfbWFuLmZlZV9yb3VuZC5uYXRpdmUgKiByb3VuZHNfcmVtYWluCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCAzMiA4CiAgICBidG9pCiAgICB1bmNvdmVyIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgKgogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjIzOAogICAgLy8gdmFsaWRhdG9yX2Vhcm5zID0gc2VsZi52YWxfY29uZmlnX21hbi5mZWVfcm91bmQubmF0aXZlICogKAogICAgaW50IDAKICAgIGJ5dGUgInZhbF9jb25maWdfbWFuIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfY29uZmlnX21hbiBleGlzdHMKICAgIGV4dHJhY3QgMzIgOAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyMzkKICAgIC8vIHNlbGYucm91bmRfZW5kIC0gc2VsZi5yb3VuZF9zdGFydCAtIHJvdW5kc19yZW1haW4KICAgIGludCAwCiAgICBieXRlICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHJvdW5kX2VuZCBleGlzdHMKICAgIGludCAwCiAgICBieXRlICJyb3VuZF9zdGFydCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcm91bmRfc3RhcnQgZXhpc3RzCiAgICAtCiAgICB1bmNvdmVyIDIKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjM4LTI0MAogICAgLy8gdmFsaWRhdG9yX2Vhcm5zID0gc2VsZi52YWxfY29uZmlnX21hbi5mZWVfcm91bmQubmF0aXZlICogKAogICAgLy8gICAgIHNlbGYucm91bmRfZW5kIC0gc2VsZi5yb3VuZF9zdGFydCAtIHJvdW5kc19yZW1haW4KICAgIC8vICkKICAgICoKICAgIGR1cAogICAgZnJhbWVfYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI0Mi0yNDMKICAgIC8vICMgSWYgY29udHJhY3Qgd2FzIGJyZWFjaGVkLCAgdGhlIHZhbGlkYXRvciBnZXRzIGFsc28gdGhlIGRlcG9zaXQKICAgIC8vIGlmIHNlbGYuY29udHJhY3RfYnJlYWNoZWQ6CiAgICBpbnQgMAogICAgYnl0ZSAiY29udHJhY3RfYnJlYWNoZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGNvbnRyYWN0X2JyZWFjaGVkIGV4aXN0cwogICAgc3dhcAogICAgZnJhbWVfYnVyeSA0CiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDEKICAgIGJ6IGVuZF9jb250cmFjdF9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjQ0CiAgICAvLyB2YWxpZGF0b3JfZWFybnMgKz0gZGVwb3NpdAogICAgZnJhbWVfZGlnIDMKICAgIGZyYW1lX2RpZyAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI0NQogICAgLy8gZGVwb3NpdCA9IFVJbnQ2NCgwKQogICAgaW50IDAKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfYnVyeSA0CgplbmRfY29udHJhY3RfYWZ0ZXJfaWZfZWxzZUA1OgogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2RpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI0OQogICAgLy8gYXJjNC5VSW50NjQoZGVwb3NpdCksCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI1MAogICAgLy8gYXJjNC5VSW50NjQocmVmdW5kX2Ftb3VudCksCiAgICBmcmFtZV9kaWcgMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNTEKICAgIC8vIGFyYzQuVUludDY0KHZhbGlkYXRvcl9lYXJucyksCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjQ3LTI1MgogICAgLy8gIyBSZXR1cm4gYWdyZWVkIGRlcG9zaXQsIHVudXNlZCBvcGVyYXRpb25hbCBmZWUsIGFuZCB1c2VkIG9wZXJhdGlvbmFsIGZlZSAoaS5lLiB2YWxpZGF0b3IgZWFybmluZykKICAgIC8vIHJldHVybiBTdHJ1Y3QzVUludDY0KAogICAgLy8gICAgIGFyYzQuVUludDY0KGRlcG9zaXQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHJlZnVuZF9hbW91bnQpLAogICAgLy8gICAgIGFyYzQuVUludDY0KHZhbGlkYXRvcl9lYXJucyksCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Quc3Rha2VfbGltaXRfYnJlYWNoKCkgLT4gYnl0ZXM6CnN0YWtlX2xpbWl0X2JyZWFjaDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjU2LTI1OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBzdGFrZV9saW1pdF9icmVhY2goCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gYXJjNC5Cb29sOgogICAgcHJvdG8gMCAxCiAgICBieXRlICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI2MwogICAgLy8gbm90IHNlbGYuY29udHJhY3RfYnJlYWNoZWQKICAgIGludCAwCiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgY29udHJhY3RfYnJlYWNoZWQgZXhpc3RzCiAgICAhCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI2Mi0yNjQKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbm90IHNlbGYuY29udHJhY3RfYnJlYWNoZWQKICAgIC8vICksICJObyBuZWVkIHRvIHN0b3JlIGZ1cnRoZXIgYnJlYWNoZXMgaWYgY29udHJhY3QgaGFzIGFscmVhZHkgYmVlbiBicmVhY2hlZC4iCiAgICBhc3NlcnQgLy8gTm8gbmVlZCB0byBzdG9yZSBmdXJ0aGVyIGJyZWFjaGVzIGlmIGNvbnRyYWN0IGhhcyBhbHJlYWR5IGJlZW4gYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI2NwogICAgLy8gc2VsZi5rZXlzX2NvbmZpcm1lZAogICAgaW50IDAKICAgIGJ5dGUgImtleXNfY29uZmlybWVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBrZXlzX2NvbmZpcm1lZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjY2LTI2OAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLmtleXNfY29uZmlybWVkCiAgICAvLyApLCAiS2V5cyBuZWVkIHRvIGJlIGNvbmZpcm1lZCBiZWZvcmUgdHJhY2tpbmcgb2YgYnJlYWNoZXMgaXMgZW5hYmxlZC4iCiAgICBhc3NlcnQgLy8gS2V5cyBuZWVkIHRvIGJlIGNvbmZpcm1lZCBiZWZvcmUgdHJhY2tpbmcgb2YgYnJlYWNoZXMgaXMgZW5hYmxlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjcxCiAgICAvLyBzZWxmLnZhbF9jb25maWdfbWFuLmJyZWFjaF9yb3VuZHMubmF0aXZlICsgc2VsZi5sYXN0X2JyZWFjaF9yb3VuZAogICAgaW50IDAKICAgIGJ5dGUgInZhbF9jb25maWdfbWFuIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayB2YWxfY29uZmlnX21hbiBleGlzdHMKICAgIGV4dHJhY3QgNzIgOAogICAgYnRvaQogICAgaW50IDAKICAgIGJ5dGUgImxhc3RfYnJlYWNoX3JvdW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBsYXN0X2JyZWFjaF9yb3VuZCBleGlzdHMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjcyCiAgICAvLyA8IEdsb2JhbC5yb3VuZAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3MS0yNzIKICAgIC8vIHNlbGYudmFsX2NvbmZpZ19tYW4uYnJlYWNoX3JvdW5kcy5uYXRpdmUgKyBzZWxmLmxhc3RfYnJlYWNoX3JvdW5kCiAgICAvLyA8IEdsb2JhbC5yb3VuZAogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNzAtMjczCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYudmFsX2NvbmZpZ19tYW4uYnJlYWNoX3JvdW5kcy5uYXRpdmUgKyBzZWxmLmxhc3RfYnJlYWNoX3JvdW5kCiAgICAvLyAgICAgPCBHbG9iYWwucm91bmQKICAgIC8vICksICJDaGVjayBpZiBtb3JlIHRoYW4gYWdyZWVkIG51bWJlciBvZiByb3VuZHMgaGFzIHBhc3NlZCBzaW5jZSBsYXN0IGJyZWFjaC4iCiAgICBhc3NlcnQgLy8gQ2hlY2sgaWYgbW9yZSB0aGFuIGFncmVlZCBudW1iZXIgb2Ygcm91bmRzIGhhcyBwYXNzZWQgc2luY2UgbGFzdCBicmVhY2guCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3NgogICAgLy8gc2VsZi5kZWxfYWNjLmJhbGFuY2UgPiBzZWxmLnZhbF9jb25maWdfbWFuLm1heF9hbXQKICAgIGludCAwCiAgICBieXRlICJ2YWxfY29uZmlnX21hbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2NvbmZpZ19tYW4gZXhpc3RzCiAgICBleHRyYWN0IDE2IDgKICAgIGludCAwCiAgICBieXRlICJkZWxfYWNjIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYWNjIGV4aXN0cwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGl0b2IKICAgIGI8CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3Ni0yNzcKICAgIC8vIHNlbGYuZGVsX2FjYy5iYWxhbmNlID4gc2VsZi52YWxfY29uZmlnX21hbi5tYXhfYW10CiAgICAvLyBvciBzZWxmLmRlbF9hY2MuYmFsYW5jZSA8IHNlbGYudmFsX2NvbmZpZ19tYW4ubWluX2FtdAogICAgYm56IHN0YWtlX2xpbWl0X2JyZWFjaF9ib29sX3RydWVAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNzcKICAgIC8vIG9yIHNlbGYuZGVsX2FjYy5iYWxhbmNlIDwgc2VsZi52YWxfY29uZmlnX21hbi5taW5fYW10CiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2NvbmZpZ19tYW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHZhbF9jb25maWdfbWFuIGV4aXN0cwogICAgZXh0cmFjdCA4IDgKICAgIGludCAwCiAgICBieXRlICJkZWxfYWNjIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBkZWxfYWNjIGV4aXN0cwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGl0b2IKICAgIGI+CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3Ni0yNzcKICAgIC8vIHNlbGYuZGVsX2FjYy5iYWxhbmNlID4gc2VsZi52YWxfY29uZmlnX21hbi5tYXhfYW10CiAgICAvLyBvciBzZWxmLmRlbF9hY2MuYmFsYW5jZSA8IHNlbGYudmFsX2NvbmZpZ19tYW4ubWluX2FtdAogICAgYnogc3Rha2VfbGltaXRfYnJlYWNoX2Jvb2xfZmFsc2VAMwoKc3Rha2VfbGltaXRfYnJlYWNoX2Jvb2xfdHJ1ZUAyOgogICAgaW50IDEKICAgIGIgc3Rha2VfbGltaXRfYnJlYWNoX2Jvb2xfbWVyZ2VANAoKc3Rha2VfbGltaXRfYnJlYWNoX2Jvb2xfZmFsc2VAMzoKICAgIGludCAwCgpzdGFrZV9saW1pdF9icmVhY2hfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNzUtMjc4CiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIHNlbGYuZGVsX2FjYy5iYWxhbmNlID4gc2VsZi52YWxfY29uZmlnX21hbi5tYXhfYW10CiAgICAvLyAgICAgb3Igc2VsZi5kZWxfYWNjLmJhbGFuY2UgPCBzZWxmLnZhbF9jb25maWdfbWFuLm1pbl9hbXQKICAgIC8vICksICJEZWxlZ2F0b3IgYWNjb3VudCBiYWxhbmNlIGlzIG91dHNpZGUgb2YgYWdyZWVkIGxpbWl0cy4iCiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIGFjY291bnQgYmFsYW5jZSBpcyBvdXRzaWRlIG9mIGFncmVlZCBsaW1pdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4MQogICAgLy8gc2VsZi5yb3VuZF9zdGFydCA8IEdsb2JhbC5yb3VuZCA8IHNlbGYucm91bmRfZW5kCiAgICBpbnQgMAogICAgYnl0ZSAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHJvdW5kX3N0YXJ0IGV4aXN0cwogICAgZ2xvYmFsIFJvdW5kCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgPAogICAgYnogc3Rha2VfbGltaXRfYnJlYWNoX2Jvb2xfZmFsc2VANwogICAgaW50IDAKICAgIGJ5dGUgInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgcm91bmRfZW5kIGV4aXN0cwogICAgZnJhbWVfZGlnIDAKICAgID4KICAgIGJ6IHN0YWtlX2xpbWl0X2JyZWFjaF9ib29sX2ZhbHNlQDcKICAgIGludCAxCiAgICBiIHN0YWtlX2xpbWl0X2JyZWFjaF9ib29sX21lcmdlQDgKCnN0YWtlX2xpbWl0X2JyZWFjaF9ib29sX2ZhbHNlQDc6CiAgICBpbnQgMAoKc3Rha2VfbGltaXRfYnJlYWNoX2Jvb2xfbWVyZ2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjgwLTI4MgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0IDwgR2xvYmFsLnJvdW5kIDwgc2VsZi5yb3VuZF9lbmQKICAgIC8vICksICJCcmVhY2hpbmcgaXMgcmVsZXZhbnQgb25seSBpbnNpZGUgY29udHJhY3QgdmFsaWRpdHkuIgogICAgYXNzZXJ0IC8vIEJyZWFjaGluZyBpcyByZWxldmFudCBvbmx5IGluc2lkZSBjb250cmFjdCB2YWxpZGl0eS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mjg0CiAgICAvLyBzZWxmLm51bV9icmVhY2ggKz0gMQogICAgaW50IDAKICAgIGJ5dGUgIm51bV9icmVhY2giCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIG51bV9icmVhY2ggZXhpc3RzCiAgICBpbnQgMQogICAgKwogICAgYnl0ZSAibnVtX2JyZWFjaCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4NQogICAgLy8gc2VsZi5jb250cmFjdF9icmVhY2hlZCA9IHNlbGYubnVtX2JyZWFjaCA+PSBzZWxmLnZhbF9jb25maWdfbWFuLm1heF9icmVhY2gKICAgIGludCAwCiAgICBieXRlICJ2YWxfY29uZmlnX21hbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2NvbmZpZ19tYW4gZXhpc3RzCiAgICBleHRyYWN0IDY0IDgKICAgIGludCAwCiAgICBieXRlICJudW1fYnJlYWNoIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBudW1fYnJlYWNoIGV4aXN0cwogICAgaXRvYgogICAgYjw9CiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4NgogICAgLy8gc2VsZi5sYXN0X2JyZWFjaF9yb3VuZCA9IEdsb2JhbC5yb3VuZAogICAgYnl0ZSAibGFzdF9icmVhY2hfcm91bmQiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4OAogICAgLy8gcmV0dXJuIGFyYzQuQm9vbChzZWxmLmNvbnRyYWN0X2JyZWFjaGVkKQogICAgaW50IDAKICAgIGJ5dGUgImNvbnRyYWN0X2JyZWFjaGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBjb250cmFjdF9icmVhY2hlZCBleGlzdHMKICAgIGJ5dGUgMHgwMAogICAgaW50IDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBzd2FwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmRlcmVnX2JyZWFjaCgpIC0+IGJ5dGVzOgpkZXJlZ19icmVhY2g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI5MC0yOTMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZGVyZWdfYnJlYWNoKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuQm9vbDoKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDMKICAgIC8vIGFzc2VydCBzZWxmLmNhbGxlZF9ieV92YWxpZGF0b3JfYWQoKSwgIk5vdCBjYWxsZWQgYnkgdmFsaWRhdG9yIGFwcC4iCiAgICBjYWxsc3ViIGNhbGxlZF9ieV92YWxpZGF0b3JfYWQKICAgIGFzc2VydCAvLyBOb3QgY2FsbGVkIGJ5IHZhbGlkYXRvciBhcHAuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMwNQogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmNvbnRyYWN0X2JyZWFjaGVkLCAiQWxyZWFkeSBoYXMgYmVlbiBicmVhY2hlZC4iCiAgICBpbnQgMAogICAgYnl0ZSAiY29udHJhY3RfYnJlYWNoZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGNvbnRyYWN0X2JyZWFjaGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIEFscmVhZHkgaGFzIGJlZW4gYnJlYWNoZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMwOAogICAgLy8gc2VsZi5rZXlzX2NvbmZpcm1lZAogICAgaW50IDAKICAgIGJ5dGUgImtleXNfY29uZmlybWVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBrZXlzX2NvbmZpcm1lZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzA3LTMwOQogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLmtleXNfY29uZmlybWVkCiAgICAvLyApLCAiS2V5cyBuZWVkIHRvIGJlIGNvbmZpcm1lZCBiZWZvcmUgdHJhY2tpbmcgb2YgYnJlYWNoZXMgaXMgZW5hYmxlZC4iCiAgICBhc3NlcnQgLy8gS2V5cyBuZWVkIHRvIGJlIGNvbmZpcm1lZCBiZWZvcmUgdHJhY2tpbmcgb2YgYnJlYWNoZXMgaXMgZW5hYmxlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzEyCiAgICAvLyBzZWxmLnZhbF9hcHBfaWQsIEJ5dGVzKGIibWFuYWdlciIpCiAgICBpbnQgMAogICAgYnl0ZSAidmFsX2FwcF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdmFsX2FwcF9pZCBleGlzdHMKICAgIGJ5dGUgIm1hbmFnZXIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxMS0zMTMKICAgIC8vIHZhbF9tbmcsIHZhbF9tbmdfZXhpc3QgPSBvcC5BcHBHbG9iYWwuZ2V0X2V4X2J5dGVzKAogICAgLy8gICAgIHNlbGYudmFsX2FwcF9pZCwgQnl0ZXMoYiJtYW5hZ2VyIikKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxNAogICAgLy8gYXNzZXJ0IHZhbF9tbmdfZXhpc3QsICJWbGlkYXRvciBjb250cmFjdCBoYXMgbWFuYWdlci4iCiAgICBhc3NlcnQgLy8gVmxpZGF0b3IgY29udHJhY3QgaGFzIG1hbmFnZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxNQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gQWNjb3VudCh2YWxfbW5nKSwgIk1hbmFnZXIgY2FsbGVkIGJyZWNhaCBrZXkgZGVyZWcuIgogICAgdHhuIFNlbmRlcgogICAgc3dhcAogICAgZHVwCiAgICBsZW4KICAgIGludCAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgPT0KICAgIGFzc2VydCAvLyBNYW5hZ2VyIGNhbGxlZCBicmVjYWgga2V5IGRlcmVnLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMTcKICAgIC8vIHNlbGYuY29udHJhY3RfYnJlYWNoZWQgPSBUcnVlCiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIGludCAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMTkKICAgIC8vIHJldHVybiBhcmM0LkJvb2woc2VsZi5jb250cmFjdF9icmVhY2hlZCkKICAgIGludCAwCiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgY29udHJhY3RfYnJlYWNoZWQgZXhpc3RzCiAgICBieXRlIDB4MDAKICAgIGludCAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5fX2luaXRfXygpIC0+IHZvaWQ6Cl9faW5pdF9fOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0OAogICAgLy8gZGVmIF9faW5pdF9fKHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDktNTAKICAgIC8vICMgRGVmaW5lIGdsb2JhbCBzdGF0ZQogICAgLy8gc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQgPSBVSW50NjQoMCkKICAgIGJ5dGUgIm5vdGljZWJvYXJkX2FwcF9pZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MQogICAgLy8gc2VsZi52YWxfYXBwX2lkID0gVUludDY0KDApCiAgICBieXRlICJ2YWxfYXBwX2lkIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUyCiAgICAvLyBzZWxmLmRlbF9hY2MgPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBieXRlICJkZWxfYWNjIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MwogICAgLy8gc2VsZi52YWxfY29uZmlnX21hbiA9IFZhbENvbmZpZ01hbigKICAgIGJ5dGUgInZhbF9jb25maWdfbWFuIgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1My02NQogICAgLy8gc2VsZi52YWxfY29uZmlnX21hbiA9IFZhbENvbmZpZ01hbigKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICBhcmM0LlVJbnQ2NCgwKSwKICAgIC8vICkKICAgIGJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjcKICAgIC8vIFZhbE5hbWUuZnJvbV9ieXRlcyhvcC5iemVybygzMCkpLAogICAgaW50IDMwCiAgICBiemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2OAogICAgLy8gVmFsTGluay5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDcwKSksCiAgICBpbnQgNzAKICAgIGJ6ZXJvCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2LTY5CiAgICAvLyBzZWxmLnZhbF9jb25maWdfZXh0cmEgPSBWYWxDb25maWdFeHRyYSgKICAgIC8vICAgICBWYWxOYW1lLmZyb21fYnl0ZXMob3AuYnplcm8oMzApKSwKICAgIC8vICAgICBWYWxMaW5rLmZyb21fYnl0ZXMob3AuYnplcm8oNzApKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NgogICAgLy8gc2VsZi52YWxfY29uZmlnX2V4dHJhID0gVmFsQ29uZmlnRXh0cmEoCiAgICBieXRlICJ2YWxfY29uZmlnX2V4dHJhIgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2Ni02OQogICAgLy8gc2VsZi52YWxfY29uZmlnX2V4dHJhID0gVmFsQ29uZmlnRXh0cmEoCiAgICAvLyAgICAgVmFsTmFtZS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDMwKSksCiAgICAvLyAgICAgVmFsTGluay5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDcwKSksCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MAogICAgLy8gc2VsZi5yb3VuZF9zdGFydCA9IFVJbnQ2NCgwKQogICAgYnl0ZSAicm91bmRfc3RhcnQiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzEKICAgIC8vIHNlbGYucm91bmRfZW5kID0gVUludDY0KDApCiAgICBieXRlICJyb3VuZF9lbmQiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzIKICAgIC8vIHNlbGYudm90ZV9rZXlfZGlsdXRpb24gPSBVSW50NjQoMCkKICAgIGJ5dGUgInZvdGVfa2V5X2RpbHV0aW9uIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjczCiAgICAvLyBzZWxmLnNlbF9rZXkgPSBTZWxLZXkuZnJvbV9ieXRlcyhvcC5iemVybygzMikpCiAgICBpbnQgMzIKICAgIGJ6ZXJvCiAgICBieXRlICJzZWxfa2V5IgogICAgZGlnIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0CiAgICAvLyBzZWxmLnZvdGVfa2V5ID0gVm90ZUtleS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDMyKSkKICAgIGJ5dGUgInZvdGVfa2V5IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzUKICAgIC8vIHNlbGYuc3RhdGVfcHJvb2Zfa2V5ID0gU3RhdGVQcm9vZktleS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDY0KSkKICAgIGludCA2NAogICAgYnplcm8KICAgIGJ5dGUgInN0YXRlX3Byb29mX2tleSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc3CiAgICAvLyBzZWxmLnBhcnRfa2V5c19kZXBvc2l0ZWQgPSBGYWxzZQogICAgYnl0ZSAicGFydF9rZXlzX2RlcG9zaXRlZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3OAogICAgLy8gc2VsZi5rZXlzX2NvbmZpcm1lZCA9IEZhbHNlCiAgICBieXRlICJrZXlzX2NvbmZpcm1lZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MAogICAgLy8gc2VsZi5udW1fYnJlYWNoID0gVUludDY0KDApCiAgICBieXRlICJudW1fYnJlYWNoIgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgxCiAgICAvLyBzZWxmLmxhc3RfYnJlYWNoX3JvdW5kID0gVUludDY0KDApCiAgICBieXRlICJsYXN0X2JyZWFjaF9yb3VuZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MgogICAgLy8gc2VsZi5jb250cmFjdF9icmVhY2hlZCA9IEZhbHNlCiAgICBieXRlICJjb250cmFjdF9icmVhY2hlZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCg==",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNsZWFyX3N0YXRlX3Byb2dyYW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3LTI4CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0KToKICAgIGludCAxCiAgICByZXR1cm4K"
    },
    "state": {
        "global": {
            "num_byte_slices": 6,
            "num_uints": 10
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 0
        }
    },
    "schema": {
        "global": {
            "declared": {
                "contract_breached": {
                    "type": "uint64",
                    "key": "contract_breached"
                },
                "del_acc": {
                    "type": "bytes",
                    "key": "del_acc"
                },
                "keys_confirmed": {
                    "type": "uint64",
                    "key": "keys_confirmed"
                },
                "last_breach_round": {
                    "type": "uint64",
                    "key": "last_breach_round"
                },
                "noticeboard_app_id": {
                    "type": "uint64",
                    "key": "noticeboard_app_id"
                },
                "num_breach": {
                    "type": "uint64",
                    "key": "num_breach"
                },
                "part_keys_deposited": {
                    "type": "uint64",
                    "key": "part_keys_deposited"
                },
                "round_end": {
                    "type": "uint64",
                    "key": "round_end"
                },
                "round_start": {
                    "type": "uint64",
                    "key": "round_start"
                },
                "sel_key": {
                    "type": "bytes",
                    "key": "sel_key"
                },
                "state_proof_key": {
                    "type": "bytes",
                    "key": "state_proof_key"
                },
                "val_app_id": {
                    "type": "uint64",
                    "key": "val_app_id"
                },
                "val_config_extra": {
                    "type": "bytes",
                    "key": "val_config_extra"
                },
                "val_config_man": {
                    "type": "bytes",
                    "key": "val_config_man"
                },
                "vote_key": {
                    "type": "bytes",
                    "key": "vote_key"
                },
                "vote_key_dilution": {
                    "type": "uint64",
                    "key": "vote_key_dilution"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {},
            "reserved": {}
        }
    },
    "contract": {
        "name": "DelegatorContract",
        "methods": [
            {
                "name": "create",
                "args": [
                    {
                        "type": "address",
                        "name": "del_acc"
                    },
                    {
                        "type": "uint64",
                        "name": "noticeboard_app_id"
                    },
                    {
                        "type": "uint64",
                        "name": "round_start"
                    },
                    {
                        "type": "uint64",
                        "name": "round_end"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "set_mandatory",
                "args": [
                    {
                        "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)",
                        "name": "val_config_man"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "set_extra",
                "args": [
                    {
                        "type": "(byte[30],byte[70])",
                        "name": "val_config_extra"
                    }
                ],
                "returns": {
                    "type": "void"
                }
            },
            {
                "name": "deposit_keys",
                "args": [
                    {
                        "type": "byte[32]",
                        "name": "sel_key"
                    },
                    {
                        "type": "byte[32]",
                        "name": "vote_key"
                    },
                    {
                        "type": "byte[64]",
                        "name": "state_proof_key"
                    },
                    {
                        "type": "uint64",
                        "name": "vote_key_dilution"
                    },
                    {
                        "type": "uint64",
                        "name": "round_start"
                    },
                    {
                        "type": "uint64",
                        "name": "round_end"
                    }
                ],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "confirm_keys",
                "args": [
                    {
                        "type": "uint64",
                        "name": "fee_operation_payment_amount"
                    },
                    {
                        "type": "byte[32]",
                        "name": "sel_key"
                    },
                    {
                        "type": "byte[32]",
                        "name": "vote_key"
                    },
                    {
                        "type": "byte[64]",
                        "name": "state_proof_key"
                    },
                    {
                        "type": "uint64",
                        "name": "vote_key_dilution"
                    },
                    {
                        "type": "uint64",
                        "name": "round_start"
                    },
                    {
                        "type": "uint64",
                        "name": "round_end"
                    }
                ],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "keys_not_generated",
                "args": [],
                "returns": {
                    "type": "(uint64,uint64)"
                }
            },
            {
                "name": "keys_not_confirmed",
                "args": [],
                "returns": {
                    "type": "(uint64,uint64)"
                }
            },
            {
                "name": "end_contract",
                "args": [],
                "returns": {
                    "type": "(uint64,uint64,uint64)"
                }
            },
            {
                "name": "stake_limit_breach",
                "args": [],
                "returns": {
                    "type": "bool"
                },
                "desc": "Anyone can trigger storing of a stake limit breach event."
            },
            {
                "name": "dereg_breach",
                "args": [],
                "returns": {
                    "type": "bool"
                },
                "desc": "Currently, manager can arbitrarily call dereg breach.\nFOR FUTURE: Change to checking if there was a key dereg transaction signed in the delegation window. Need to upload and check the signature of the transaction in SC. *If program size is a problem, the service could be a completely separate SC."
            }
        ],
        "networks": {},
        "desc": "\n    Contract between a user, i.e. delegator, and node runner, i.e. valdiator, for the latter to participate in consensus\n    on the behalf of the user for specific amount of time and for a specific fee.\n    The contract terms are defined in this contract.\n\n    Global state\n    ------------\n        Configuration parameters\n        ------------------------\n\n\n        Variables\n        ---------\n\n    Methods\n    -------\n\n    "
    },
    "bare_call_config": {}
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


@dataclasses.dataclass(kw_only=True)
class DeployCreate(algokit_utils.DeployCreateCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


@dataclasses.dataclass(kw_only=True)
class Deploy(algokit_utils.DeployCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data)
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class ValConfigMan:
    hw_cat: int
    min_amt: int
    max_amt: int
    fee_setup: int
    fee_round: int
    deposit: int
    setup_rounds: int
    confirmation_rounds: int
    max_breach: int
    breach_rounds: int
    uptime_gar: int


@dataclasses.dataclass(kw_only=True)
class SetMandatoryArgs(_ArgsBase[None]):
    val_config_man: ValConfigMan

    @staticmethod
    def method() -> str:
        return "set_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64))void"


@dataclasses.dataclass(kw_only=True)
class ValConfigExtra:
    name: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    link: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class SetExtraArgs(_ArgsBase[None]):
    val_config_extra: ValConfigExtra

    @staticmethod
    def method() -> str:
        return "set_extra((byte[30],byte[70]))void"


@dataclasses.dataclass(kw_only=True)
class DepositKeysArgs(_ArgsBase[int]):
    sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key_dilution: int
    round_start: int
    round_end: int

    @staticmethod
    def method() -> str:
        return "deposit_keys(byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64"


@dataclasses.dataclass(kw_only=True)
class ConfirmKeysArgs(_ArgsBase[int]):
    fee_operation_payment_amount: int
    sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    vote_key_dilution: int
    round_start: int
    round_end: int

    @staticmethod
    def method() -> str:
        return "confirm_keys(uint64,byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64"


@dataclasses.dataclass(kw_only=True)
class StakeLimitBreachArgs(_ArgsBase[bool]):
    """Anyone can trigger storing of a stake limit breach event."""

    @staticmethod
    def method() -> str:
        return "stake_limit_breach()bool"


@dataclasses.dataclass(kw_only=True)
class DeregBreachArgs(_ArgsBase[bool]):
    """Currently, manager can arbitrarily call dereg breach.
    FOR FUTURE: Change to checking if there was a key dereg transaction signed in the delegation window. Need to upload and check the signature of the transaction in SC. *If program size is a problem, the service could be a completely separate SC."""

    @staticmethod
    def method() -> str:
        return "dereg_breach()bool"


@dataclasses.dataclass(kw_only=True)
class CreateArgs(_ArgsBase[None]):
    del_acc: str
    noticeboard_app_id: int
    round_start: int
    round_end: int

    @staticmethod
    def method() -> str:
        return "create(address,uint64,uint64,uint64)void"


@dataclasses.dataclass(kw_only=True)
class Struct2UInt64:
    a: int
    b: int


@dataclasses.dataclass(kw_only=True)
class KeysNotGeneratedArgs(_ArgsBase[Struct2UInt64]):
    @staticmethod
    def method() -> str:
        return "keys_not_generated()(uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class KeysNotConfirmedArgs(_ArgsBase[Struct2UInt64]):
    @staticmethod
    def method() -> str:
        return "keys_not_confirmed()(uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class Struct3UInt64:
    a: int
    b: int
    c: int


@dataclasses.dataclass(kw_only=True)
class EndContractArgs(_ArgsBase[Struct3UInt64]):
    @staticmethod
    def method() -> str:
        return "end_contract()(uint64,uint64,uint64)"


class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()


class GlobalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.contract_breached = typing.cast(int, data.get(b"contract_breached"))
        self.del_acc = ByteReader(typing.cast(bytes, data.get(b"del_acc")))
        self.keys_confirmed = typing.cast(int, data.get(b"keys_confirmed"))
        self.last_breach_round = typing.cast(int, data.get(b"last_breach_round"))
        self.noticeboard_app_id = typing.cast(int, data.get(b"noticeboard_app_id"))
        self.num_breach = typing.cast(int, data.get(b"num_breach"))
        self.part_keys_deposited = typing.cast(int, data.get(b"part_keys_deposited"))
        self.round_end = typing.cast(int, data.get(b"round_end"))
        self.round_start = typing.cast(int, data.get(b"round_start"))
        self.sel_key = ByteReader(typing.cast(bytes, data.get(b"sel_key")))
        self.state_proof_key = ByteReader(typing.cast(bytes, data.get(b"state_proof_key")))
        self.val_app_id = typing.cast(int, data.get(b"val_app_id"))
        self.val_config_extra = ByteReader(typing.cast(bytes, data.get(b"val_config_extra")))
        self.val_config_man = ByteReader(typing.cast(bytes, data.get(b"val_config_man")))
        self.vote_key = ByteReader(typing.cast(bytes, data.get(b"vote_key")))
        self.vote_key_dilution = typing.cast(int, data.get(b"vote_key_dilution"))


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def set_mandatory(
        self,
        *,
        val_config_man: ValConfigMan,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `set_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64))void` ABI method
        
        :param ValConfigMan val_config_man: The `val_config_man` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetMandatoryArgs(
            val_config_man=val_config_man,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def set_extra(
        self,
        *,
        val_config_extra: ValConfigExtra,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `set_extra((byte[30],byte[70]))void` ABI method
        
        :param ValConfigExtra val_config_extra: The `val_config_extra` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = SetExtraArgs(
            val_config_extra=val_config_extra,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def deposit_keys(
        self,
        *,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `deposit_keys(byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64` ABI method
        
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = DepositKeysArgs(
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def confirm_keys(
        self,
        *,
        fee_operation_payment_amount: int,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `confirm_keys(uint64,byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64` ABI method
        
        :param int fee_operation_payment_amount: The `fee_operation_payment_amount` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ConfirmKeysArgs(
            fee_operation_payment_amount=fee_operation_payment_amount,
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def stake_limit_breach(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Anyone can trigger storing of a stake limit breach event.
        
        Adds a call to `stake_limit_breach()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = StakeLimitBreachArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def dereg_breach(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Currently, manager can arbitrarily call dereg breach.
        FOR FUTURE: Change to checking if there was a key dereg transaction signed in the delegation window. Need to upload and check the signature of the transaction in SC. *If program size is a problem, the service could be a completely separate SC.
        
        Adds a call to `dereg_breach()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = DeregBreachArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_create(
        self,
        *,
        del_acc: str,
        noticeboard_app_id: int,
        round_start: int,
        round_end: int,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `create(address,uint64,uint64,uint64)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param int noticeboard_app_id: The `noticeboard_app_id` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CreateArgs(
            del_acc=del_acc,
            noticeboard_app_id=noticeboard_app_id,
            round_start=round_start,
            round_end=round_end,
        )
        self.app_client.compose_create(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_keys_not_generated(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `keys_not_generated()(uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotGeneratedArgs()
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_keys_not_confirmed(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `keys_not_confirmed()(uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotConfirmedArgs()
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_end_contract(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `end_contract()(uint64,uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = EndContractArgs()
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class DelegatorContractClient:
    """
        Contract between a user, i.e. delegator, and node runner, i.e. valdiator, for the latter to participate in consensus
        on the behalf of the user for specific amount of time and for a specific fee.
        The contract terms are defined in this contract.
    
        Global state
        ------------
            Configuration parameters
            ------------------------
    
    
            Variables
            ---------
    
        Methods
        -------
    
        
    
    A class for interacting with the DelegatorContract app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        DelegatorContractClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def get_global_state(self) -> GlobalState:
        """Returns the application's global state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_global_state(raw=True))
        return GlobalState(state)

    def set_mandatory(
        self,
        *,
        val_config_man: ValConfigMan,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `set_mandatory((uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64))void` ABI method
        
        :param ValConfigMan val_config_man: The `val_config_man` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetMandatoryArgs(
            val_config_man=val_config_man,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def set_extra(
        self,
        *,
        val_config_extra: ValConfigExtra,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `set_extra((byte[30],byte[70]))void` ABI method
        
        :param ValConfigExtra val_config_extra: The `val_config_extra` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = SetExtraArgs(
            val_config_extra=val_config_extra,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def deposit_keys(
        self,
        *,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `deposit_keys(byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64` ABI method
        
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = DepositKeysArgs(
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def confirm_keys(
        self,
        *,
        fee_operation_payment_amount: int,
        sel_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        state_proof_key: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        vote_key_dilution: int,
        round_start: int,
        round_end: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `confirm_keys(uint64,byte[32],byte[32],byte[64],uint64,uint64,uint64)uint64` ABI method
        
        :param int fee_operation_payment_amount: The `fee_operation_payment_amount` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] sel_key: The `sel_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] vote_key: The `vote_key` ABI parameter
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] state_proof_key: The `state_proof_key` ABI parameter
        :param int vote_key_dilution: The `vote_key_dilution` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = ConfirmKeysArgs(
            fee_operation_payment_amount=fee_operation_payment_amount,
            sel_key=sel_key,
            vote_key=vote_key,
            state_proof_key=state_proof_key,
            vote_key_dilution=vote_key_dilution,
            round_start=round_start,
            round_end=round_end,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def stake_limit_breach(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """Anyone can trigger storing of a stake limit breach event.
        
        Calls `stake_limit_breach()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction"""

        args = StakeLimitBreachArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def dereg_breach(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """Currently, manager can arbitrarily call dereg breach.
        FOR FUTURE: Change to checking if there was a key dereg transaction signed in the delegation window. Need to upload and check the signature of the transaction in SC. *If program size is a problem, the service could be a completely separate SC.
        
        Calls `dereg_breach()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction"""

        args = DeregBreachArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_create(
        self,
        *,
        del_acc: str,
        noticeboard_app_id: int,
        round_start: int,
        round_end: int,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Calls `create(address,uint64,uint64,uint64)void` ABI method
        
        :param str del_acc: The `del_acc` ABI parameter
        :param int noticeboard_app_id: The `noticeboard_app_id` ABI parameter
        :param int round_start: The `round_start` ABI parameter
        :param int round_end: The `round_end` ABI parameter
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = CreateArgs(
            del_acc=del_acc,
            noticeboard_app_id=noticeboard_app_id,
            round_start=round_start,
            round_end=round_end,
        )
        result = self.app_client.create(
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return result

    def delete_keys_not_generated(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Struct2UInt64]:
        """Calls `keys_not_generated()(uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Struct2UInt64]: The result of the transaction"""

        args = KeysNotGeneratedArgs()
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Struct2UInt64(**result_dict)
        return result

    def delete_keys_not_confirmed(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Struct2UInt64]:
        """Calls `keys_not_confirmed()(uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Struct2UInt64]: The result of the transaction"""

        args = KeysNotConfirmedArgs()
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Struct2UInt64(**result_dict)
        return result

    def delete_end_contract(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Struct3UInt64]:
        """Calls `end_contract()(uint64,uint64,uint64)` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Struct3UInt64]: The result of the transaction"""

        args = EndContractArgs()
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Struct3UInt64(**result_dict)
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: DeployCreate[CreateArgs],
        update_args: algokit_utils.DeployCallArgs | None = None,
        delete_args: Deploy[KeysNotGeneratedArgs | KeysNotConfirmedArgs | EndContractArgs],
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param DeployCreate[CreateArgs] create_args: Arguments used when creating an application
        :param algokit_utils.DeployCallArgs | None update_args: Arguments used when updating an application
        :param Deploy[KeysNotGeneratedArgs | KeysNotConfirmedArgs | EndContractArgs] delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())
